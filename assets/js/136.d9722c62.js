(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{616:function(e,v,_){"use strict";_.r(v);var s=_(32),t=Object(s.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"_1-主从复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-主从复制"}},[e._v("#")]),e._v(" 1.主从复制")]),e._v(" "),_("h3",{attrs:{id:"主从复制原理："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从复制原理："}},[e._v("#")]),e._v(" 主从复制原理：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("从服务器连接主服务器，发送SYNC命令；")])]),e._v(" "),_("li",[_("p",[e._v("主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；")])]),e._v(" "),_("li",[_("p",[e._v("主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；")])]),e._v(" "),_("li",[_("p",[e._v("从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；")])]),e._v(" "),_("li",[_("p",[e._v("主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；")])]),e._v(" "),_("li",[_("p",[e._v("从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（从服务器初始化完成）")])]),e._v(" "),_("li",[_("p",[e._v("主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）")])])]),e._v(" "),_("ul",[_("li",[_("strong",[e._v("优点")]),e._v("：")])]),e._v(" "),_("p",[e._v("支持主从复制，主机会自动将数据同步到从机，可以进行读写分离")]),e._v(" "),_("p",[e._v("为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成")]),e._v(" "),_("p",[e._v("Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。")]),e._v(" "),_("p",[e._v("Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。")]),e._v(" "),_("p",[e._v("Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据")]),e._v(" "),_("ul",[_("li",[_("strong",[e._v("缺点")]),e._v("：")])]),e._v(" "),_("p",[e._v("Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。")]),e._v(" "),_("p",[e._v("主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。")]),e._v(" "),_("p",[e._v("Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。")]),e._v(" "),_("h2",{attrs:{id:"_2-哨兵模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-哨兵模式"}},[e._v("#")]),e._v(" 2.哨兵模式")]),e._v(" "),_("p",[e._v("当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。")]),e._v(" "),_("p",[e._v("哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("监控主服务器和从服务器是否正常运行。")])]),e._v(" "),_("li",[_("p",[e._v("主服务器出现故障时自动将从服务器转换为主服务器。")])])]),e._v(" "),_("ul",[_("li",[_("p",[e._v("哨兵的工作方式：")]),e._v(" "),_("p",[e._v("每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。")]),e._v(" "),_("p",[e._v("如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）")]),e._v(" "),_("p",[e._v("如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态")]),e._v(" "),_("p",[e._v("当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）\n在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。")]),e._v(" "),_("p",[e._v("当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。\n若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。")])]),e._v(" "),_("li",[_("p",[e._v("优点：")]),e._v(" "),_("p",[e._v("哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。主从可以自动切换，系统更健壮，可用性更高。")])]),e._v(" "),_("li",[_("p",[e._v("缺点：")]),e._v(" "),_("p",[e._v("Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。")])])]),e._v(" "),_("h2",{attrs:{id:"_3-redis-cluster集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis-cluster集群"}},[e._v("#")]),e._v(" 3.Redis-Cluster集群")]),e._v(" "),_("p",[e._v("redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。")]),e._v(" "),_("p",[e._v("Redis-Cluster采用无中心结构,它的特点如下：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。")])]),e._v(" "),_("li",[_("p",[e._v("节点的fail是通过集群中超过半数的节点检测失效时才生效。")])]),e._v(" "),_("li",[_("p",[e._v("客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。")])])]),e._v(" "),_("ul",[_("li",[e._v("工作方式：")])]),e._v(" "),_("p",[e._v("在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。")]),e._v(" "),_("p",[e._v("为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。")])])}),[],!1,null,null,null);v.default=t.exports}}]);